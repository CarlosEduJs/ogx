---
title: Performance
description: Real-world benchmarks and optimization strategies
---

OGX is engineered for speed. This page documents real-world performance metrics and provides strategies to optimize your OG image generation.

## Benchmark Results

The following benchmarks were run on **Node.js 24** with 100 iterations per scenario.

| Scenario | Mean | Notes |
|:---------|:-----|:------|
| **Minimal Preset** | 60.02ms | Fast and lightweight, perfect for simple images and blogs. |
| **Social Preset** | 693.12ms | Complex gradients, multiple fonts, rich layout, shadows. Still faster than competitors. |
| **Docs Preset** | 88.92ms | Ideal for documentation pages or content-heavy layouts. |
| **With Cache** | 0.7ms | **85x faster** than cold render. Instant retrieval via snapshot caching. |

> [!TIP]
> The cache system provides **sub-millisecond** response times for repeated renders with the same configuration.

## Why OGX is Fast

### 1. No Browser Required

Unlike Puppeteer-based solutions, OGX uses **Satori** for layout and **Resvg** for rasterizationâ€”both are native/WASM-based and don't require a browser instance.

### 2. Tailwind JIT Parsing

OGX parses Tailwind classes at runtime using an optimized JIT compiler, avoiding the need for full CSS processing.

### 3. Built-in Caching

The cache system serializes the entire OGX configuration into a hash key, enabling instant retrieval for identical requests.

## Optimization Strategies

### Use Simpler Presets

If performance is critical, prefer `minimal` or `docs` presets over `social` (which includes gradients):

```ts
// Fast (~60ms)
await ogx({ preset: "minimal", title: "Hello" });

// Slower (~700ms) - but still faster than @vercel/og
await ogx({ preset: "social", title: "Hello", brand: "OGX" });
```

### Enable Caching

Always enable caching in production for repeated configurations:

```ts
await ogx({
  preset: "docs",
  title: "My Page",
  cache: true, // Enable built-in cache
});
```

### Pre-register Fonts

Register fonts before rendering to avoid per-request font loading:

```ts
import { fontRegistry } from "@ogxjs/core";

// Do this once at startup
await fontRegistry.registerInter([400, 700]);
```

### Use Static Generation

In Next.js, prefer static generation over on-demand rendering:

```ts
// app/og/[slug]/route.ts
export const dynamic = "force-static";
export const revalidate = 3600; // Revalidate every hour

export async function GET(req: Request) {
  return ogxResponse({ preset: "docs", title: "..." }, req);
}
```

## Run Benchmarks Yourself

You can run the official benchmarks locally:

```bash
pnpm -F @ogxjs/core bench
```

This will generate:
- `benchmarks/results.json` - Raw data
- `benchmarks/BENCHMARKS.md` - Formatted report

## Environment

Benchmarks were run on:
- **Runtime:** Node.js v24.12.0
- **Platform:** Linux (x64)
- **Iterations:** 100 per scenario
